/*
    Copyright (c) 2023-2024 CodeWin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include <sstream>
#include <algorithm>
#include <vector>
#include <cstring>
#include "SubtitleTrack_AssImpl.h"
#include "SubtitleClip_AssImpl.h"
#include "FFUtils.h"
extern "C"
{
    #include "libavutil/avutil.h"
    #include "libavutil/avstring.h"
    #include "libswscale/swscale.h"
}

using namespace std;
using namespace MediaCore;
using namespace Logger;
using std::placeholders::_1;
using std::placeholders::_2;

static void PrintAssStyle(ALogger* logger, ASS_Style* s)
{
    logger->Log(DEBUG) << "------------------- ASS Style --------------------" << endl;
    logger->Log(DEBUG) << '\t' << "Name: " << s->Name << endl;
    logger->Log(DEBUG) << '\t' << "FontName: " << s->FontName << endl;
    logger->Log(DEBUG) << '\t' << "FontSize: " << s->FontSize << endl;
    logger->Log(DEBUG) << '\t' << "PrimaryColor: " << s->PrimaryColour << endl;
    logger->Log(DEBUG) << '\t' << "SecondaryColor: " << s->SecondaryColour << endl;
    logger->Log(DEBUG) << '\t' << "OutlineColor:" << s->OutlineColour << endl;
    logger->Log(DEBUG) << '\t' << "BackColor: " << s->BackColour << endl;
    logger->Log(DEBUG) << '\t' << "Bold: " << s->Bold << endl;
    logger->Log(DEBUG) << '\t' << "Italic: " << s->Italic << endl;
    logger->Log(DEBUG) << '\t' << "Underline: " << s->Underline << endl;
    logger->Log(DEBUG) << '\t' << "StrikeOut: " << s->StrikeOut << endl;
    logger->Log(DEBUG) << '\t' << "ScaleX: " << s->ScaleX << endl;
    logger->Log(DEBUG) << '\t' << "ScaleY: " << s->ScaleY << endl;
    logger->Log(DEBUG) << '\t' << "Spacing: " << s->Spacing << endl;
    logger->Log(DEBUG) << '\t' << "Angle: " << s->Angle << endl;
    logger->Log(DEBUG) << '\t' << "BorderStyle: " << s->BorderStyle << endl;
    logger->Log(DEBUG) << '\t' << "Outline: " << s->Outline << endl;
    logger->Log(DEBUG) << '\t' << "Shadow: " << s->Shadow << endl;
    logger->Log(DEBUG) << '\t' << "Alignment: " << s->Alignment << endl;
    logger->Log(DEBUG) << '\t' << "MarginL: " << s->MarginL << endl;
    logger->Log(DEBUG) << '\t' << "MarginR: " << s->MarginR << endl;
    logger->Log(DEBUG) << '\t' << "MarginV: " << s->MarginV << endl;
    logger->Log(DEBUG) << '\t' << "Encoding: " << s->Encoding << endl;
    logger->Log(DEBUG) << '\t' << "treat_fontname_as_pattern: " << s->treat_fontname_as_pattern << endl;
    logger->Log(DEBUG) << '\t' << "Blur: " << s->Blur << endl;
    //logger->Log(DEBUG) << '\t' << "Justify: " << s->Justify << endl;
    logger->Log(DEBUG) << "--------------------------------------------------" << endl;
}

static string GenerateAssHeader(const char* provider,
                                int play_res_x, int play_res_y,
                                const char *font, int font_size,
                                int primary_color, int secondary_color,
                                int outline_color, int back_color,
                                int bold, int italic, int underline,
                                int border_style, int alignment)
{
    char ass_header_buf[1024];
    snprintf(ass_header_buf, sizeof(ass_header_buf),
            "[Script Info]\r\n"
            "; Script generated by %s\r\n"
            "ScriptType: v4.00+\r\n"
            "PlayResX: %d\r\n"
            "PlayResY: %d\r\n"
            "ScaledBorderAndShadow: yes\r\n"
            "\r\n"
            "[V4+ Styles]\r\n"

            /* ASSv4 header */
            "Format: Name, "
            "Fontname, Fontsize, "
            "PrimaryColour, SecondaryColour, OutlineColour, BackColour, "
            "Bold, Italic, Underline, StrikeOut, "
            "ScaleX, ScaleY, "
            "Spacing, Angle, "
            "BorderStyle, Outline, Shadow, "
            "Alignment, MarginL, MarginR, MarginV, "
            "Encoding\r\n"

            "Style: "
            "Default,"             /* Name */
            "%s,%d,"               /* Font{name,size} */
            "&H%x,&H%x,&H%x,&H%x," /* {Primary,Secondary,Outline,Back}Colour */
            "%d,%d,%d,0,"          /* Bold, Italic, Underline, StrikeOut */
            "100,100,"             /* Scale{X,Y} */
            "0,0,"                 /* Spacing, Angle */
            "%d,1,0,"              /* BorderStyle, Outline, Shadow */
            "%d,10,10,10,"         /* Alignment, Margin[LRV] */
            "0\r\n"                /* Encoding */

            "\r\n"
            "[Events]\r\n"
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n",
            provider,
            play_res_x, play_res_y, font, font_size,
            primary_color, secondary_color, outline_color, back_color,
            -bold, -italic, -underline, border_style, alignment);

    return string(ass_header_buf);
}

SubtitleTrackStyle_AssImpl::SubtitleTrackStyle_AssImpl(const ASS_Style* style)
{
    BuildFromAssStyle(style);
}

SubtitleTrackStyle_AssImpl::SubtitleTrackStyle_AssImpl(const SubtitleTrackStyle_AssImpl& a)
{
    BuildFromAssStyle(&a.m_assStyle);
    m_offsetV = a.m_offsetV;
    m_foffsetV = a.m_foffsetV;
}

SubtitleTrackStyle_AssImpl& SubtitleTrackStyle_AssImpl::operator=(const SubtitleTrackStyle_AssImpl& a)
{
    BuildFromAssStyle(&a.m_assStyle);
    m_offsetV = a.m_offsetV;
    m_foffsetV = a.m_foffsetV;
    return *this;
}

void SubtitleTrackStyle_AssImpl::BuildFromAssStyle(const ASS_Style* assStyle)
{
    memcpy(&m_assStyle, assStyle, sizeof(m_assStyle));
    int l = strlen(assStyle->Name);
    m_name = unique_ptr<char[]>(new char[l+1]);
    snprintf(m_name.get(), l+1, "%s", assStyle->Name);
    m_assStyle.Name = m_name.get();
    l = strlen(assStyle->FontName);
    m_fontName = unique_ptr<char[]>(new char[l+1]);
    snprintf(m_fontName.get(), l+1, "%s", assStyle->FontName);
    m_assStyle.FontName = m_fontName.get();
    uint32_t c = assStyle->PrimaryColour;
    m_primaryColor = SubtitleColor((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    c = assStyle->SecondaryColour;
    m_secondaryColor = SubtitleColor((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    c = assStyle->OutlineColour;
    m_outlineColor = SubtitleColor((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    c = assStyle->BackColour;
    m_backColor = SubtitleColor((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    m_bold = 0;
    if (assStyle->Bold == FONT_WEIGHT_LIGHT)
        m_bold = 1;
    else if (assStyle->Bold == FONT_WEIGHT_BOLD)
        m_bold = 2;
    m_italic = 0;
    if (assStyle->Italic == FONT_SLANT_ITALIC)
        m_italic = 1;
    else if (assStyle->Italic == FONT_SLANT_OBLIQUE)
        m_italic = 2;
    if (assStyle->Alignment >= 1 && assStyle->Alignment <= 3)
        m_alignment = assStyle->Alignment;
    else if (assStyle->Alignment >= 5 && assStyle->Alignment <= 7)
        m_alignment = assStyle->Alignment+2;
    else if (assStyle->Alignment >= 9 && assStyle->Alignment <= 11)
        m_alignment = assStyle->Alignment-5;
}

void SubtitleTrackStyle_AssImpl::SetFont(const string& font)
{
    int l = font.size();
    unique_ptr<char[]> newfont(new char[l+1]);
    snprintf(newfont.get(), l+1, "%s", font.c_str());
    m_fontName = std::move(newfont);
    m_assStyle.FontName = m_fontName.get();
}

void SubtitleTrackStyle_AssImpl::SetPrimaryColor(const SubtitleColor& color)
{
    m_primaryColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_assStyle.PrimaryColour = c;
}

void SubtitleTrackStyle_AssImpl::SetSecondaryColor(const SubtitleColor& color)
{
    m_secondaryColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_assStyle.SecondaryColour = c;
}

void SubtitleTrackStyle_AssImpl::SetOutlineColor(const SubtitleColor& color)
{
    m_outlineColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_assStyle.OutlineColour = c;
}

void SubtitleTrackStyle_AssImpl::SetBackColor(const SubtitleColor& color)
{
    m_backColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_assStyle.BackColour = c;
}

void SubtitleTrackStyle_AssImpl::SetBackgroundColor(const SubtitleColor& color)
{
    m_bgColor = color;
}

void SubtitleTrackStyle_AssImpl::SetBold(int value)
{
    value = value<0 ? 0 : (value>2 ? 2 : value);
    m_bold = value;
    if (value == 0)
        m_assStyle.Bold = FONT_WEIGHT_MEDIUM;
    else if (value == 1)
        m_assStyle.Bold = FONT_WEIGHT_LIGHT;
    else
        m_assStyle.Bold = FONT_WEIGHT_BOLD;
}

void SubtitleTrackStyle_AssImpl::SetItalic(int value)
{
    value = value<0 ? 0 : (value>2 ? 2 : value);
    m_italic = value;
    if (value == 0)
        m_assStyle.Italic = FONT_SLANT_NONE;
    else if (value == 1)
        m_assStyle.Italic = FONT_SLANT_ITALIC;
    else
        m_assStyle.Italic = FONT_SLANT_OBLIQUE;
}

void SubtitleTrackStyle_AssImpl::SetAlignment(int value)
{
    value = value<1 ? 1 : (value>9 ? 9 : value);
    m_alignment = value;
    int a = value;
    if (a >= 4 && a <= 6)
        a += 5;
    else if (a >= 7 && a <= 9)
        a -= 2;
    else if (a < 1 || a > 3)
        a = 2;
    m_assStyle.Alignment = a;
}

static bool SubClipSortCmp(const SubtitleClipHolder& a, const SubtitleClipHolder& b)
{
    return a->StartTime() < b->StartTime();
}

SubtitleTrack_AssImpl::SubtitleTrack_AssImpl(int64_t id)
    : m_id(id)
{
    m_logger = GetSubtitleTrackLogger();
    m_currIter = m_clips.begin();
}

SubtitleTrack_AssImpl::~SubtitleTrack_AssImpl()
{
    if (m_assrnd)
    {
        ass_renderer_done(m_assrnd);
        m_assrnd = nullptr;
    }
    if (m_asstrk)
    {
        ass_free_track(m_asstrk);
        m_asstrk = nullptr;
    }
    ReleaseFFContext();
}

bool SubtitleTrack_AssImpl::InitAss()
{
    if (!s_asslib)
    {
        m_errMsg = "ASS library has NOT been INITIALIZED!";
        return false;
    }
    m_assrnd = ass_renderer_init(s_asslib);
    if (!m_assrnd)
    {
        m_errMsg = "FAILED to initialize ASS renderer!";
        return false;
    }
    ass_set_fonts(m_assrnd, NULL, NULL, ASS_FONTPROVIDER_AUTODETECT, NULL, 1);
    ass_set_pixel_aspect(m_assrnd, 1);
    m_asstrk = ass_new_track(s_asslib);
    if (!m_asstrk)
    {
        m_errMsg = "FAILED to create a new ASS track!";
        return false;
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetFrameSize(uint32_t width, uint32_t height)
{
    ass_set_frame_size(m_assrnd, width, height);
    m_frmW = width;
    m_frmH = height;
    return true;
}

bool SubtitleTrack_AssImpl::EnableFullSizeOutput(bool enable)
{
    if (m_outputFullSize == enable)
        return true;
    m_outputFullSize = enable;
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetFont(const std::string& font)
{
    if (m_overrideStyle.Font() == font)
        return true;
    m_logger->Log(DEBUG) << "Set font '" << font << "'" << endl;
    m_overrideStyle.SetFont(font);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetScaleX(double value)
{
    return _SetScaleX(value);
}

bool SubtitleTrack_AssImpl::_SetScaleX(double value, bool clearCache)
{
    if (m_overrideStyle.ScaleX() == value)
        return true;
    m_logger->Log(DEBUG) << "Set scaleX '" << value << "'" << endl;
    m_overrideStyle.SetScaleX(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetScaleY(double value)
{
    return _SetScaleY(value);
}

bool SubtitleTrack_AssImpl::_SetScaleY(double value, bool clearCache)
{
    if (m_overrideStyle.ScaleY() == value)
        return true;
    m_logger->Log(DEBUG) << "Set scaleY '" << value << "'" << endl;
    m_overrideStyle.SetScaleY(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetSpacing(double value)
{
    return _SetSpacing(value);
}

bool SubtitleTrack_AssImpl::_SetSpacing(double value, bool clearCache)
{
    if (m_overrideStyle.Spacing() == value)
        return true;
    m_logger->Log(DEBUG) << "Set spacing '" << value << "'" << endl;
    m_overrideStyle.SetSpacing(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetAngle(double value)
{
    return _SetAngle(value);
}

bool SubtitleTrack_AssImpl::_SetAngle(double value, bool clearCache)
{
    if (m_overrideStyle.Angle() == value)
        return true;
    m_logger->Log(DEBUG) << "Set angle '" << value << "'" << endl;
    m_overrideStyle.SetAngle(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetOutlineWidth(double value)
{
    return _SetOutlineWidth(value);
}

bool SubtitleTrack_AssImpl::_SetOutlineWidth(double value, bool clearCache)
{
    if (m_overrideStyle.OutlineWidth() == value)
        return true;
    m_logger->Log(DEBUG) << "Set outline '" << value << "'" << endl;
    m_overrideStyle.SetOutlineWidth(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetShadowDepth(double value)
{
    return _SetShadowDepth(value);
}

bool SubtitleTrack_AssImpl::_SetShadowDepth(double value, bool clearCache)
{
    if (m_overrideStyle.ShadowDepth() == value)
        return true;
    m_logger->Log(DEBUG) << "Set shadow depth '" << value << "'" << endl;
    m_overrideStyle.SetShadowDepth(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    if (clearCache)
        ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBorderStyle(int value)
{
    if (m_overrideStyle.BorderStyle() == value)
        return true;
    m_logger->Log(DEBUG) << "Set border style '" << value << "'" << endl;
    m_overrideStyle.SetBorderStyle(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetAlignment(int value)
{
    if (m_overrideStyle.Alignment() == value)   
        return true;
    m_logger->Log(DEBUG) << "Set alignment '" << value << "'" << endl;
    m_overrideStyle.SetAlignment(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetH(int value)
{
    return _SetOffsetH(value);
}

bool SubtitleTrack_AssImpl::_SetOffsetH(int value, bool clearCache)
{
    if (m_overrideStyle.OffsetH() == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetH '" << value << "'" << endl;
    int32_t bias = value-m_overrideStyle.OffsetH();
    m_overrideStyle.SetOffsetH(value);
    if (clearCache)
    {
        if (m_outputFullSize)
            ClearRenderCache();
        else
        {
            for (auto& clip : m_clips)
            {
                SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
                assClip->UpdateImageAreaX(bias);
            }
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetV(int value)
{
    return _SetOffsetV(value);
}

bool SubtitleTrack_AssImpl::_SetOffsetV(int value, bool clearCache)
{
    if (m_overrideStyle.OffsetV() == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetV '" << value << "'" << endl;
    int32_t bias = value-m_overrideStyle.OffsetV();
    m_overrideStyle.SetOffsetV(value);
    if (clearCache)
    {
        if (m_outputFullSize)
            ClearRenderCache();
        else
        {
            for (auto& clip : m_clips)
            {
                SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
                assClip->UpdateImageAreaY(bias);
            }
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetH(float value)
{
    return _SetOffsetH(value);
}

bool SubtitleTrack_AssImpl::_SetOffsetH(float value, bool clearCache)
{
    if (m_overrideStyle.OffsetHScale() == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetHScale '" << value << "'" << endl;
    auto bias = value-m_overrideStyle.OffsetHScale();
    m_overrideStyle.SetOffsetH(value);
    if (clearCache)
    {
        if (m_outputFullSize)
            ClearRenderCache();
        else
        {
            for (auto& clip : m_clips)
            {
                SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
                assClip->UpdateImageAreaX(bias);
            }
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetV(float value)
{
    return _SetOffsetV(value);
}

bool SubtitleTrack_AssImpl::_SetOffsetV(float value, bool clearCache)
{
    if (m_overrideStyle.OffsetVScale() == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetVScale '" << value << "'" << endl;
    auto bias = value-m_overrideStyle.OffsetVScale();
    m_overrideStyle.SetOffsetV(value);
    if (clearCache)
    {
        if (m_outputFullSize)
            ClearRenderCache();
        else
        {
            for (auto& clip : m_clips)
            {
                SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
                assClip->UpdateImageAreaY(bias);
            }
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetCompensationV(int32_t value)
{
    if (m_offsetCompensationV == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetCompensationV '" << value << "'" << endl;
    int32_t bias = value-m_offsetCompensationV;
    m_offsetCompensationV = value;
    if (m_outputFullSize)
        ClearRenderCache();
    else
    {
        for (auto& clip : m_clips)
        {
            SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
            assClip->UpdateImageAreaY(bias);
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetOffsetCompensationV(float value)
{
    if (m_foffsetCompensationV == value)
        return true;
    m_logger->Log(DEBUG) << "Set offsetCompensationV Scale'" << value << "'" << endl;
    auto bias = value-m_foffsetCompensationV;
    m_foffsetCompensationV = value;
    if (m_outputFullSize)
        ClearRenderCache();
    else
    {
        for (auto& clip : m_clips)
        {
            SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
            assClip->UpdateImageAreaY(bias);
        }
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetItalic(int value)
{
    if (m_overrideStyle.Italic() == value)
        return true;
    m_logger->Log(DEBUG) << "Set italic '" << value << "'" << endl;
    m_overrideStyle.SetItalic(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBold(int value)
{
    if (m_overrideStyle.Bold() == value)
        return true;
    m_logger->Log(DEBUG) << "Set bold '" << value << "'" << endl;
    m_overrideStyle.SetBold(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetUnderLine(bool enable)
{
    if (m_overrideStyle.UnderLine() == enable)
        return true;
    m_logger->Log(DEBUG) << "Set underline '" << enable << "'" << endl;
    m_overrideStyle.SetUnderLine(enable);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetStrikeOut(bool enable)
{
    if (m_overrideStyle.StrikeOut() == enable)
        return true;
    m_logger->Log(DEBUG) << "Set strikeout '" << enable << "'" << endl;
    m_overrideStyle.SetStrikeOut(enable);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetPrimaryColor(const SubtitleColor& color)
{
    if (m_overrideStyle.PrimaryColor() == color)
        return true;
    m_logger->Log(DEBUG) << "Set primary color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetPrimaryColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetSecondaryColor(const SubtitleColor& color)
{
    if (m_overrideStyle.SecondaryColor() == color)
        return true;
    m_logger->Log(DEBUG) << "Set secondary color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetSecondaryColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetOutlineColor(const SubtitleColor& color)
{
    if (m_overrideStyle.OutlineColor() == color)
        return true;
    m_logger->Log(DEBUG) << "Set outline color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetOutlineColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBackColor(const SubtitleColor& color)
{
    if (m_overrideStyle.BackColor() == color)
        return true;
    m_logger->Log(DEBUG) << "Set back color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetBackColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBackgroundColor(const SubtitleColor& color)
{
    if (m_overrideStyle.BackgroundColor() == color)
        return true;
    m_logger->Log(DEBUG) << "Set background color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetBackgroundColor(color);
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetPrimaryColor(const ImVec4& color)
{
    const SubtitleColor _color(color.x, color.y, color.z, color.w);
    return SetPrimaryColor(_color);
}

bool SubtitleTrack_AssImpl::SetSecondaryColor(const ImVec4& color)
{
    const SubtitleColor _color(color.x, color.y, color.z, color.w);
    return SetSecondaryColor(_color);
}

bool SubtitleTrack_AssImpl::SetOutlineColor(const ImVec4& color)
{
    const SubtitleColor _color(color.x, color.y, color.z, color.w);
    return SetOutlineColor(_color);
}

bool SubtitleTrack_AssImpl::SetBackColor(const ImVec4& color)
{
    const SubtitleColor _color(color.x, color.y, color.z, color.w);
    return SetBackColor(_color);
}

bool SubtitleTrack_AssImpl::SetBackgroundColor(const ImVec4& color)
{
    const SubtitleColor _color(color.x, color.y, color.z, color.w);
    return SetBackgroundColor(_color);
}

void SubtitleTrack_AssImpl::Refresh()
{
    ClearRenderCache();
}

bool SubtitleTrack_AssImpl::SetKeyPoints(const ImGui::KeyPointEditor& keyPoints)
{
    m_overrideStyle.SetKeyPoints(keyPoints);
    return true;
}

ImGui::KeyPointEditor* SubtitleTrack_AssImpl::GetKeyPoints()
{
    return m_overrideStyle.GetKeyPoints();
}

bool SubtitleTrack_AssImpl::ChangeClipTime(SubtitleClipHolder clip, int64_t startTime, int64_t duration)
{
    if (!clip)
    {
        m_errMsg = "Argument 'clip' CANNOT be NULL!";
        return false;
    }
    int32_t idx = 0;
    auto iter = m_clips.begin();
    while (iter != m_clips.end())
    {
        if (*iter == clip)
            break;
        idx++;
        iter++;
    }
    if (iter == m_clips.end())
    {
        m_errMsg = "Can NOT FIND the target clip in the clip list!";
        return false;
    }
    if (clip->StartTime() == startTime && clip->Duration() == duration)
    {
        // does not change anything
        return true;
    }

    // invalidate the clips affected by removing the target clip from its original position
    auto iter2 = iter;
    while (iter2 != m_clips.end())
    {
        iter2++;
        if (iter2 != m_clips.end() && clip->EndTime() > (*iter2)->StartTime())
            (*iter2)->InvalidateImage();
        else
            break;
    }

    // find the new insertion position
    iter2 = iter;
    int posOffset = 0;
    if (startTime > clip->StartTime())
    {
        iter2++;
        while (iter2 != m_clips.end() && startTime > (*iter2)->StartTime())
        {
            (*iter2)->InvalidateImage();
            posOffset++;
            iter2++;
        }
    }
    else if (startTime < clip->StartTime())
    {
        while (iter2 != m_clips.begin())
        {
            iter2--;
            if (startTime < (*iter2)->StartTime())
            {
                (*iter2)->InvalidateImage();
                posOffset--;
            }
            else
            {
                iter2++;
                break;
            }
        }
    }

    // update the clip time information and insert it at new position
    SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
    assClip->SetStartTime(startTime);
    assClip->SetDuration(duration);

    if (posOffset != 0)
    {
        m_clips.erase(iter);
        m_clips.insert(iter2, clip);
    }

    // invalidate the clips affected by inserting the target clip to its new position
    while (iter2 != m_clips.end())
    {
        if (clip->EndTime() > (*iter2)->StartTime())
        {
            (*iter2)->InvalidateImage();
            iter2++;
        }
        else
            break;
    }

    // update duration
    if (clip->EndTime() > m_duration)
    {
        m_duration = clip->EndTime();
    }
    return true;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetClipByTime(int64_t ms)
{
    if (m_clips.size() <= 0)
        return nullptr;
    if (m_currIter != m_clips.end() && (*m_currIter)->StartTime() <= ms && (*m_currIter)->EndTime() > ms)
        return *m_currIter;

    if (m_currIter == m_clips.end() || (*m_currIter)->StartTime() > ms)
    {
        auto iter = m_currIter;
        while (iter != m_clips.begin())
        {
            iter--;
            if ((*iter)->EndTime() <= ms)
            {
                iter++;
                break;
            }
            else if ((*iter)->StartTime() <= ms)
            {
                break;
            }
        }
        m_currIter = iter;
    }
    else
    {
        auto iter = m_currIter;
        iter++;
        while (iter != m_clips.end())
        {
            if ((*iter)->EndTime() > ms)
                break;
            iter++;
        }
        m_currIter = iter;
    }

    if (m_currIter == m_clips.end())
        return nullptr;
    if ((*m_currIter)->StartTime() <= ms && (*m_currIter)->EndTime() > ms)
        return *m_currIter;
    return nullptr;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetCurrClip()
{
    if (m_currIter == m_clips.end())
        return nullptr;
    return *m_currIter;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetPrevClip()
{
    if (m_currIter == m_clips.begin())
        return nullptr;
    m_currIter--;
    return *m_currIter;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetNextClip()
{
    if (m_currIter == m_clips.end())
        return nullptr;
    m_currIter++;
    if (m_currIter == m_clips.end())
        return nullptr;
    return *m_currIter;
}

int32_t SubtitleTrack_AssImpl::GetClipIndex(SubtitleClipHolder clip) const
{
    if (!clip)
        return -1;
    int32_t idx = 0;
    auto iter = m_clips.begin();
    while (iter != m_clips.end())
    {
        if (*iter == clip)
            break;
        idx++;
        iter++;
    }
    if (iter == m_clips.end())
        return -1;
    return idx;
}

uint32_t SubtitleTrack_AssImpl::GetCurrIndex() const
{
    if (m_currIter == m_clips.end())
        return m_clips.size();
    uint32_t idx = 0;
    auto iter = m_clips.begin();
    while (iter != m_currIter)
    {
        iter++;
        idx++;
    }
    return idx;
}

bool SubtitleTrack_AssImpl::SeekToTime(int64_t ms)
{
    m_readPos = ms;
    auto iter = find_if(m_clips.begin(), m_clips.end(), [ms] (SubtitleClipHolder clip) {
        return clip->StartTime() > ms;
    });
    m_currIter = iter;
    if (iter != m_clips.begin())
    {
        iter--;
        if ((*iter)->EndTime() > ms)
            m_currIter = iter;
    }

    return true;
}

bool SubtitleTrack_AssImpl::SeekToIndex(uint32_t index)
{
    if (index >= m_clips.size())
    {
        ostringstream oss;
        oss << "Index (" << index << ") exceeds the number of subtitle clips (" << m_clips.size() << ")!";
        m_errMsg = oss.str();
        return false;
    }
    uint32_t loopCnt = index;
    auto iter = m_clips.begin();
    while (loopCnt > 0 && iter != m_clips.end())
    {
        iter++;
        loopCnt--;
    }
    m_currIter = iter;
    m_readPos = (*iter)->StartTime();
    return true;
}

SubtitleClipHolder SubtitleTrack_AssImpl::NewClip(int64_t startTime, int64_t duration)
{
    // find the insert position
    auto iter = m_clips.begin();
    while (iter != m_clips.end() && (*iter)->StartTime() <= startTime)
    {
        iter++;
    }

    ASS_Event* orgPtr = m_asstrk->events;
    int eid = ass_alloc_event(m_asstrk);
    ASS_Event* assEvent = m_asstrk->events+eid;
    assEvent->ReadOrder = eid;
    assEvent->Style = m_defaultStyleIdx;
    assEvent->Text = (char*)malloc(1);
    assEvent->Text[0] = 0;
    assEvent->Start = startTime;
    assEvent->Duration = duration;

    // if ASS_Track::events ptr reallocated, then resync ASS_Event ptr with all the SubtitleClips
    if (orgPtr && orgPtr != m_asstrk->events)
    {
        auto iter2 = m_clips.begin();
        while (iter2 != m_clips.end())
        {
            SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(iter2->get());
            const int targetIdx = assClip->ReadOrder();
            assClip->ResyncAssEventPtr(m_asstrk->events+targetIdx);
            iter2++;
        }
    }

    SubtitleClip_AssImpl* newAssClip = new SubtitleClip_AssImpl(assEvent, m_asstrk, bind(&SubtitleTrack_AssImpl::RenderSubtitleClip, this, _1, _2, std::placeholders::_3, std::placeholders::_4));
    SubtitleClipHolder hNewClip(newAssClip);
    m_clips.insert(iter, hNewClip);

    // update duration
    if (hNewClip->EndTime() > m_duration)
    {
        m_duration = hNewClip->EndTime();
    }

    m_logger->Log(VERBOSE) << "New ASS clip is added with readOrder=" << assEvent->ReadOrder << "." << endl;
    return hNewClip;
}

bool SubtitleTrack_AssImpl::DeleteClip(SubtitleClipHolder hClip)
{
    auto iter = find(m_clips.begin(), m_clips.end(), hClip);
    if (iter == m_clips.end())
    {
        m_errMsg = "CANNOT find target 'hClip'!";
        return false;
    }
    SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(hClip.get());
    list<SubtitleClip_AssImpl*> updateAssClips;
    auto iter2 = m_clips.begin();
    while (iter2 != m_clips.end())
    {
        SubtitleClip_AssImpl* assClip2 = dynamic_cast<SubtitleClip_AssImpl*>(iter2->get());
        if (assClip2->ReadOrder() > assClip->ReadOrder())
            updateAssClips.push_back(assClip2);
        iter2++;
    }

    bool updateCurrIter = m_currIter == iter;
    int eid = assClip->ReadOrder();
    m_logger->Log(DEBUG) << "Delete ASS SubtitleClip (ReaderOrder=" << eid << ")." << endl;
    iter = m_clips.erase(iter);
    if (updateCurrIter)
        m_currIter = iter;

    // update track duration if needed
    if (hClip->EndTime() == m_duration)
    {
        int64_t duration = 0;
        for (auto& clip : m_clips)
        {
            if (clip->EndTime() > duration)
                duration = clip->EndTime();
        }
        m_duration = duration;
    }

    assClip->InvalidateClip();
    ass_free_event(m_asstrk, eid);
    if (eid < m_asstrk->n_events-1)
    {
        memmove(m_asstrk->events+eid, m_asstrk->events+eid+1, sizeof(ASS_Event)*(m_asstrk->n_events-eid-1));
        ASS_Event* iterptr = m_asstrk->events+eid;
        const ASS_Event* const endptr = m_asstrk->events+m_asstrk->n_events-1;
        while (iterptr < endptr)
            (iterptr++)->ReadOrder--;
    }
    m_asstrk->n_events--;

    for (auto& updateClip : updateAssClips)
        updateClip->AssEventPtrDecrease();

    return true;
}

static bool ConvertSubtitleClipToAVSubtitle(const SubtitleClip* clip, AVSubtitle* avsub, int readOrder)
{
    avsub->format = 1;
    avsub->pts = av_rescale_q(clip->StartTime(), MILLISEC_TIMEBASE, AV_TIME_BASE_Q);
    avsub->start_display_time = 0;
    avsub->end_display_time = clip->Duration();
    avsub->num_rects = 1;
    avsub->rects = (AVSubtitleRect**)av_malloc(sizeof(AVSubtitleRect*)*avsub->num_rects);
    for (int i = 0; i < avsub->num_rects; i++)
    {
        AVSubtitleRect* subrect = (AVSubtitleRect*)av_malloc(sizeof(AVSubtitleRect));
        avsub->rects[i] = subrect;
        memset(subrect, 0, sizeof(AVSubtitleRect));
        subrect->ass = av_asprintf("%d,%d,%s,%s,0,0,0,,%s", readOrder, 0, "Default", "", clip->Text().c_str());
    }
    return true;
}

static void FreeAVSubtitle(AVSubtitle* avsub)
{
    if (avsub->rects)
    {
        for (int i = 0; i < avsub->num_rects; i++)
        {
            AVSubtitleRect* subrect = avsub->rects[i];
            if (subrect->ass)
                av_free(subrect->ass);
            av_free(avsub->rects[i]);
        }
        av_free(avsub->rects);
    }
    memset(avsub, 0, sizeof(AVSubtitle));
}

bool SubtitleTrack_AssImpl::SaveAs(const string& assFilePath)
{
    int fferr;

    string fileExt = assFilePath.substr(assFilePath.rfind('.'), assFilePath.size());
    transform(fileExt.begin(), fileExt.end(), fileExt.begin(), [] (char c) {
        if (c <= 'Z' && c >= 'A')
            return (char)(c-('Z'-'z'));
        return c;
    });
    m_logger->Log(DEBUG) << ">>> File ext : '" << fileExt << "'." << endl;

    AVCodecID encCdcId = AV_CODEC_ID_NONE;
    if (fileExt == ".srt")
        encCdcId = AV_CODEC_ID_SUBRIP;
    else if (fileExt == ".ass" || fileExt == ".ssa")
        encCdcId = AV_CODEC_ID_ASS;
    if (encCdcId == AV_CODEC_ID_NONE)
    {
        ostringstream oss;
        oss << "Subtitle format with file-ext '" << fileExt << "' is NOT SUPPORTED!";
        m_errMsg = oss.str();
        return false;
    }

    AVCodecPtr encCdc = avcodec_find_encoder(encCdcId);
    if (!encCdc)
    {
        ostringstream oss;
        oss << "FAILED to find encoder for codec '" << avcodec_get_name(encCdcId) << "'!";
        m_errMsg = oss.str();
        return false;
    }

    AVFormatContext* outFmtCtx = nullptr;
    fferr = avformat_alloc_output_context2(&outFmtCtx, nullptr, nullptr, assFilePath.c_str());
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "FAILED to invoke 'avformat_alloc_output_context2()'! fferr = " << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    shared_ptr<AVFormatContext> outFmtCtxAutoFree(outFmtCtx, [] (AVFormatContext* ctx) {
        if (ctx)
            avformat_free_context(ctx);
    });
    if ((outFmtCtx->oformat->flags&AVFMT_NOFILE) == 0)
    {
        fferr = avio_open(&outFmtCtx->pb, assFilePath.c_str(), AVIO_FLAG_WRITE);
        if (fferr < 0)
        {
            ostringstream oss;
            oss << "FAILED to invoke 'avio_open()'! fferr = " << fferr << ".";
            m_errMsg = oss.str();
            return false;
        }
    }

    AVCodecContext* encCdcCtx = avcodec_alloc_context3(encCdc);
    if (!encCdcCtx)
    {
        m_errMsg = "FAILED to invoke 'avcodec_alloc_context3()'!";
        return false;
    }
    shared_ptr<AVCodecContext> encCdcCtxAutoFree(encCdcCtx, [] (AVCodecContext* ctx) {
        if (ctx)
            avcodec_free_context(&ctx);
    });
    encCdcCtx->time_base = AV_TIME_BASE_Q;
    if (!encCdcCtx->width)
    {
        encCdcCtx->width = m_frmW;
        encCdcCtx->height = m_frmH;
    }
    string assHeader = GenerateAssHeader("MediaEditor", 384, 288, "Arial", 16, 0xffffff, 0xffffff, 0, 0, 0, 0, 0, 1, 2);
    encCdcCtx->subtitle_header_size = assHeader.size();
    encCdcCtx->subtitle_header = (uint8_t*)av_malloc(encCdcCtx->subtitle_header_size+1);
    memcpy(encCdcCtx->subtitle_header, assHeader.c_str(), encCdcCtx->subtitle_header_size);
    encCdcCtx->subtitle_header[encCdcCtx->subtitle_header_size] = 0;

    fferr = avcodec_open2(encCdcCtx, encCdc, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "FAILED to invoke 'avcodec_open2()'! fferr = " << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }

    for (auto clip : m_clips)
    {
        AVSubtitle avsub{0};
        SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip.get());
        if (ConvertSubtitleClipToAVSubtitle(clip.get(), &avsub, assClip->ReadOrder()))
        {
            avcodec_encode_subtitle(encCdcCtx, 0, 0, &avsub);
        }
        else
        {
            m_logger->Log(Error) << "FAILED to convert ass subtitle clip (readOrder=" << assClip->ReadOrder() << ") to AVSubtitle!" << endl;
        }
        FreeAVSubtitle(&avsub);
    }

    return true;
}

SubtitleTrackHolder SubtitleTrack_AssImpl::Clone(uint32_t frmW, uint32_t frmH, bool useScale)
{
    SubtitleTrackHolder hSubTrk = NewEmptyTrack(m_id);
    SubtitleTrack_AssImpl* newTrk = dynamic_cast<SubtitleTrack_AssImpl*>(hSubTrk.get());
    newTrk->SetFrameSize(frmW, frmH);
    newTrk->SetAlignment(m_overrideStyle.Alignment());
    if (useScale)
        newTrk->SetOffsetCompensationV(m_foffsetCompensationV);
    else
        newTrk->SetOffsetCompensationV(m_offsetCompensationV);
    newTrk->EnableFullSizeOutput(false);

    const double wRatio = (double)frmW/m_frmW;
    const double hRatio = (double)frmH/m_frmH;
    auto& trkStyle = DefaultStyle();
    newTrk->SetFont(trkStyle.Font());
    newTrk->SetScaleX(trkStyle.ScaleX());
    newTrk->SetScaleY(trkStyle.ScaleY());
    newTrk->SetSpacing(trkStyle.Spacing());
    newTrk->SetAngle(trkStyle.Angle());
    newTrk->SetOutlineWidth(trkStyle.OutlineWidth());
    newTrk->SetAlignment(trkStyle.Alignment());
    newTrk->SetItalic(trkStyle.Italic());
    newTrk->SetBold(trkStyle.Bold());
    newTrk->SetUnderLine(trkStyle.UnderLine());
    newTrk->SetStrikeOut(trkStyle.StrikeOut());
    newTrk->SetPrimaryColor(trkStyle.PrimaryColor());
    newTrk->SetSecondaryColor(trkStyle.SecondaryColor());
    newTrk->SetOutlineColor(trkStyle.OutlineColor());
    newTrk->SetBackgroundColor(trkStyle.BackgroundColor());
    newTrk->SetOffsetH((int)(trkStyle.OffsetH()*wRatio));
    newTrk->SetOffsetV((int)(trkStyle.OffsetV()*hRatio));
    newTrk->SetOffsetH(trkStyle.OffsetHScale());
    newTrk->SetOffsetV(trkStyle.OffsetVScale());
    newTrk->SetKeyPoints(*(m_overrideStyle.GetKeyPoints()));

    for (auto c : m_clips)
    {
        auto c2 = newTrk->NewClip(c->StartTime(), c->Duration());
        c2->SetText(c->Text());
        if (!c->IsUsingTrackStyle())
            c2->CloneStyle(c, wRatio, hRatio);
    }
    return hSubTrk;
}

ASS_Library* SubtitleTrack_AssImpl::s_asslib = nullptr;

static void ass_log(int ass_level, const char *fmt, va_list args, void *ctx)
{
    Logger::Level level = VERBOSE;
    if (ass_level < 2)
        level = Error;
    else if (ass_level < 4)
        level = WARN;
    else if (ass_level < 5)
        level = INFO;
    else if (ass_level < 6)
        level = DEBUG;
    char buf[2048]={0};
    va_list vl;
    va_copy(vl, args);
    vsnprintf(buf, sizeof(buf)-1, fmt, vl);
    va_end(vl);
    GetSubtitleTrackLogger()->Log(level) << "[ASSLOG] " << buf << endl;
}

bool SubtitleTrack_AssImpl::Initialize()
{
    if (s_asslib)
    {
        // already initialized
        return true;
    }
    s_asslib = ass_library_init();
    if (!s_asslib)
        return false;
    ass_set_message_cb(s_asslib, ass_log, NULL);
    return true;
}

void SubtitleTrack_AssImpl::Release()
{
    if (s_asslib)
    {
        ass_library_done(s_asslib);
        s_asslib = nullptr;
    }
}

bool SubtitleTrack_AssImpl::SetFontDir(const string& path)
{
    if (!s_asslib)
        return false;
    ass_set_fonts_dir(s_asslib, path.c_str());
    return true;
}

static string StripAssStyleOverrideCodes(const char* assbuf, int len)
{
    ostringstream oss;
    bool isPrevCharBackSlash = false;
    bool isOverrideCode = false;
    for (int i = 0; i < len; i++)
    {
        const char c = assbuf[i];
        bool quitOverrideCode = false;
        if (!isPrevCharBackSlash)
        {
            if (c == '\\')
                isPrevCharBackSlash = true;
            else if (c == '{')
                isOverrideCode = true;
            else if (c == '}')
                quitOverrideCode = true;
        }
        else
        {
            isPrevCharBackSlash = false;
        }
        if (!isOverrideCode)
            oss << c;
        if (quitOverrideCode)
            isOverrideCode = false;
    }
    return oss.str();
}

bool SubtitleTrack_AssImpl::ReadFile(const string& path)
{
    ReleaseFFContext();

    int fferr;
    fferr = avformat_open_input(&m_pAvfmtCtx, path.c_str(), nullptr, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avformat_open_input() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    fferr = avformat_find_stream_info(m_pAvfmtCtx, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avformat_find_stream_info() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    int subStmIdx = -1;
    for (int i = 0; i < m_pAvfmtCtx->nb_streams; i++)
    {
        if (m_pAvfmtCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE)
        {
            subStmIdx = i;
            break;
        }
    }
    if (subStmIdx < 0)
    {
        ostringstream oss;
        oss << "CANNOT find any subtitle track in the file '" << path << "'!";
        m_errMsg = oss.str();
        return false;
    }

    AVStream* pAvStream = m_pAvfmtCtx->streams[subStmIdx];
    AVCodecPtr pAvCdc = avcodec_find_decoder(pAvStream->codecpar->codec_id);
    AVCodecContext* pAvCdcCtx = avcodec_alloc_context3(pAvCdc);
    fferr = avcodec_parameters_to_context(pAvCdcCtx, pAvStream->codecpar);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avcodec_parameters_to_context() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    pAvCdcCtx->pkt_timebase = pAvStream->time_base;
    fferr = avcodec_open2(pAvCdcCtx, pAvCdc, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avcodec_open2() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }

    if (pAvCdcCtx->subtitle_header && pAvCdcCtx->subtitle_header_size > 0)
    {
        ass_process_codec_private(m_asstrk, (char*)pAvCdcCtx->subtitle_header, pAvCdcCtx->subtitle_header_size);
        if (m_asstrk->styles && m_asstrk->n_styles > 0)
        {
            m_logger->Log(DEBUG) << m_asstrk->n_styles << " style(s) are found:" << endl;
            for (int i = 0; i < m_asstrk->n_styles; i++)
                PrintAssStyle(m_logger, m_asstrk->styles+i);
        }
    }

    m_errMsg.clear();
    bool demuxEof = false;
    bool decodeEof = false;
    while (!decodeEof)
    {
        AVPacket avpkt{0};
        if (!demuxEof)
        {
            fferr = av_read_frame(m_pAvfmtCtx, &avpkt);
            if (fferr == AVERROR_EOF)
            {
                demuxEof = true;
            }
            else if (fferr < 0)
            {
                ostringstream oss;
                oss << "av_read_frame() FAILED! fferr=" << fferr << ".";
                m_errMsg = oss.str();
                break;
            }
        }
        else
        {
            // send NULL packet to decoder to push out all subtitles if any is buffered inside
            avpkt.stream_index = subStmIdx;
        }

        AVSubtitle avsub{0};
        int gotSubPtr = 0;
        if (avpkt.stream_index == subStmIdx)
        {
            fferr = avcodec_decode_subtitle2(pAvCdcCtx, &avsub, &gotSubPtr, &avpkt);
            av_packet_unref(&avpkt);
            if (fferr == AVERROR_EOF)
            {
                decodeEof = true;
            }
            else if (fferr < 0)
            {
                ostringstream oss;
                oss << "avcodec_decode_subtitle2() FAILED! fferr=" << fferr << ".";
                m_errMsg = oss.str();
                break;
            }
        }
        else
        {
            av_packet_unref(&avpkt);
            continue;
        }

        if (gotSubPtr && avsub.end_display_time > avsub.start_display_time)
        {
            const int64_t start_time = av_rescale_q(avsub.pts, AV_TIME_BASE_Q, av_make_q(1, 1000))+avsub.start_display_time;
            const int64_t duration   = avsub.end_display_time-avsub.start_display_time;
            m_logger->Log(VERBOSE) << "[" << MillisecToString(start_time) << "(+" << duration << ")] ";
            bool isAss = true;
            for (auto i = 0; i < avsub.num_rects; i++)
            {
                if (avsub.rects[i]->type != SUBTITLE_ASS)
                {
                    isAss = false;
                    break;
                }
                char *ass_line = avsub.rects[i]->ass;
                if (!ass_line)
                    continue;
                m_logger->Log(VERBOSE) << "<" << i << ">: '" << avsub.rects[i]->ass << "'";
            }
            m_logger->Log(VERBOSE) << endl;
            if (!isAss)
            {
                m_errMsg = "The subtitle file/stream is NOT ASS! Not supported!";
                break;
            }
            for (auto i = 0; i < avsub.num_rects; i++)
            {
                char *ass_line = avsub.rects[i]->ass;
                if (!ass_line)
                    break;
                string strippedAssLine = StripAssStyleOverrideCodes(ass_line, strlen(ass_line));
#if LIBAVCODEC_VERSION_MAJOR >= 59
                ass_process_chunk(m_asstrk, (char*)(strippedAssLine.c_str()), strippedAssLine.size(), start_time, duration);
#else
                ass_process_data(m_asstrk, (char*)(strippedAssLine.c_str()), strippedAssLine.size());
#endif
            }
            avsubtitle_free(&avsub);
        }
        else if (demuxEof)
        {
            decodeEof = true;
        }
        if (gotSubPtr)
            avsubtitle_free(&avsub);
    }
    m_defaultStyleIdx = -1;
    for (int i = 0; i < m_asstrk->n_styles; i++)
    {
        string styleName(m_asstrk->styles[i].Name);
        if (styleName == "Default")
            m_defaultStyleIdx = i;
    }
    if (m_defaultStyleIdx < 0)
        m_defaultStyleIdx = m_asstrk->n_styles-1;

    if (m_defaultStyleIdx >= 0)
    {
        m_overrideStyle = SubtitleTrackStyle_AssImpl(m_asstrk->styles+m_defaultStyleIdx);
    }
    else
    {
        m_errMsg = "No style is defined for this subtitle!";
    }

    bool success = m_errMsg.empty();
    if (success)
    {
        m_duration = 0;
        for (int i = 0; i < m_asstrk->n_events; i++)
        {
            ASS_Event* e = m_asstrk->events+i;
            e->ReadOrder = i;
            SubtitleClip_AssImpl* assClip = new SubtitleClip_AssImpl(e, m_asstrk, bind(&SubtitleTrack_AssImpl::RenderSubtitleClip, this, _1, _2, std::placeholders::_3, std::placeholders::_4));
            SubtitleClipHolder hSubClip(assClip);
            m_clips.push_back(hSubClip);
            if (assClip->EndTime() > m_duration)
            {
                m_duration = assClip->EndTime();
            }
        }
        m_currIter = m_clips.begin();
    }
    return success;
}

void SubtitleTrack_AssImpl::ReleaseFFContext()
{
    if (m_pAvCdcCtx)
    {
        avcodec_free_context(&m_pAvCdcCtx);
        m_pAvCdcCtx = nullptr;
    }
    if (m_pAvfmtCtx)
    {
        avformat_close_input(&m_pAvfmtCtx);
        m_pAvfmtCtx = nullptr;
    }
}

template <typename T>
class WrapperAlloc: public allocator<T>
{
public:
    WrapperAlloc(void* buf=0) throw(): allocator<T>(), m_buf(buf) {}
    WrapperAlloc(const WrapperAlloc& a) throw(): allocator<T>(a) { m_buf = a.m_buf; }
    ~WrapperAlloc() {}

    typedef size_t size_type;
    typedef T* pointer;
    typedef const T* const_pointer;

    template<typename _Tp1>
    struct rebind
    {
        typedef WrapperAlloc<_Tp1> other;
    };

    pointer allocate(size_type n, const void* hint=0)
    {
        char* p = new (m_buf) char[n*sizeof(T)];
        return (T*)p;
    }

    void deallocate(pointer p, size_type n) {}

private:
    void* m_buf;
};

SubtitleImage SubtitleTrack_AssImpl::RenderSubtitleClip(SubtitleClip* clip, int64_t timeOffset, bool absolutePosX, bool absolutePosY)
{
    int64_t pos = clip->StartTime()+timeOffset;
    UpdateTrackStyleByKeyPoints(pos);

    SubtitleClip_AssImpl* assClip = dynamic_cast<SubtitleClip_AssImpl*>(clip);
    int detectChange = 0;
    ASS_Image* renderRes = ass_render_frame(m_assrnd, m_asstrk, pos, &detectChange);
    m_logger->Log(DEBUG) << "Render subtitle '" << assClip->GetAssText() << "', ASS_Image ptr=" << renderRes << ", detectChanged=" << detectChange << "." << endl;
    ImGui::ImMat vmat;
    if (!renderRes)
        return SubtitleImage(vmat, {0});

    // calculate the containing box
    ASS_Image* assImage = renderRes;
    SubtitleImage::Rect assBox{assImage->dst_x, assImage->dst_y, assImage->w, assImage->h};
    assImage = assImage->next;
    while (assImage)
    {
        if (assImage->dst_x < assBox.x)
        {
            assBox.w += assBox.x-assImage->dst_x;
            assBox.x = assImage->dst_x;
        }
        if (assImage->dst_x+assImage->w > assBox.x+assBox.w)
        {
            assBox.w = assImage->dst_x+assImage->w-assBox.x;
        }
        if (assImage->dst_y < assBox.y)
        {
            assBox.h += assBox.y-assImage->dst_y;
            assBox.y = assImage->dst_y;
        }
        if (assImage->dst_y+assImage->h > assBox.y+assBox.h)
        {
            assBox.h = assImage->dst_y+assImage->h-assBox.y;
        }
        assImage = assImage->next;
    }

    int frmW = (int)m_frmW;
    int frmH = (int)m_frmH;
    if (!m_outputFullSize)
    {
        frmW = assBox.w;
        frmH = assBox.h;
    }
    vmat.create_type((int)frmW, (int)frmH, 4, IM_DT_INT8);
    vmat.color_format = IM_CF_ABGR;

    // calculate the final display box
    SubtitleImage::Rect dispBox{assBox};
    //const int32_t offsetH = clip->IsUsingTrackStyle() ? m_overrideStyle.OffsetH() : clip->OffsetH();
    //const int32_t offsetV = clip->IsUsingTrackStyle() ? m_overrideStyle.OffsetV() : clip->OffsetV();
    const float offsetH = clip->IsUsingTrackStyle() ? m_overrideStyle.OffsetHScale() : clip->OffsetHScale();
    const float offsetV = clip->IsUsingTrackStyle() ? m_overrideStyle.OffsetVScale() : clip->OffsetVScale();
    if (absolutePosX)
        dispBox.x = offsetH * m_frmW;
    else
        dispBox.x += offsetH * m_frmW;
    
    if (absolutePosY)
        dispBox.y = offsetV * m_frmH;
    else
        dispBox.y += offsetV * m_frmH + m_foffsetCompensationV * m_frmH;

    m_logger->Log(DEBUG) << "--> assBox:{" << assBox.x << "," << assBox.y << "," << assBox.w << "," << assBox.h
            << "}, dispBox:{" << dispBox.x << "," << dispBox.y
            << "} offsetH/V=( " << offsetH << ", " << offsetV << ")." << endl;

    // if ASS_Image's content is not changed && only output text image, then return previous rendered image
    if (!m_outputFullSize && (detectChange == 0 || detectChange == 1))
    {
        auto prevMat = m_prevRenderedImage.Vmat();
        return SubtitleImage(prevMat, dispBox);
    }

    uint32_t color;
    // fill the image with background color
    const SubtitleColor bgColor = clip->IsUsingTrackStyle() ? m_overrideStyle.BackgroundColor() : clip->BackgroundColor();
    color = ((uint32_t)(bgColor.a*255)<<24) | ((uint32_t)(bgColor.b*255)<<16) | ((uint32_t)(bgColor.g*255)<<8) | (uint32_t)(bgColor.r*255);
    WrapperAlloc<uint32_t> wrapperAlloc((uint32_t*)vmat.data);
    vector<uint32_t, WrapperAlloc<uint32_t>> mapary(wrapperAlloc);
    mapary.resize(vmat.total()/4);
    fill(mapary.begin(), mapary.end(), color);

    // if subtitle is outside of the visible area, then return blank picture
    if (m_outputFullSize &&
       (dispBox.x+dispBox.w <= 0 || dispBox.y+dispBox.h <= 0 ||
        dispBox.x >= m_frmW || dispBox.y >= m_frmH))
    {
        return SubtitleImage(vmat, dispBox);
    }

    // draw ASS_Image list
    assImage = renderRes;
    while (assImage)
    {
        color = assImage->color;
        float baseAlpha = (float)(255-(color&0xff))/255;
        color = ((color&0xff00)<<8) | ((color>>8)&0xff00) | ((color>>24)&0xff);

        SubtitleImage::Rect drawBox{assImage->dst_x, assImage->dst_y, assImage->w, assImage->h};
        uint32_t* imgPtr;
        unsigned char* assPtr;
        if (m_outputFullSize)
        {
            drawBox.x += offsetH * m_frmW;
            drawBox.y += offsetV * m_frmH;
            if (drawBox.x+drawBox.w <= 0 || drawBox.y+dispBox.h <= 0 ||
                drawBox.x >= m_frmW || drawBox.y >= m_frmH)
            {
                assImage = assImage->next;
                continue;
            }

            int drawOffsetX{0}, drawOffsetY{0};
            if (drawBox.x < 0)
            {
                drawOffsetX = -drawBox.x;
                drawBox.w += drawBox.x;
                drawBox.x = 0;
            }
            if (drawBox.y < 0)
            {
                drawOffsetY = -drawBox.y;
                drawBox.h += drawBox.y;
                drawBox.y = 0;
            }
            if (drawBox.x+drawBox.w > m_frmW)
                drawBox.w = m_frmW-drawBox.x;
            if (drawBox.y+drawBox.h > m_frmH)
                drawBox.h = m_frmH-drawBox.y;

            imgPtr = (uint32_t*)(vmat.data)+drawBox.y*frmW+drawBox.x;
            assPtr = assImage->bitmap+drawOffsetY*assImage->stride+drawOffsetX;
        }
        else
        {
            imgPtr = (uint32_t*)(vmat.data)+(assImage->dst_y-assBox.y)*frmW+(assImage->dst_x-assBox.x);
            assPtr = assImage->bitmap;
        }
        for (int i = 0; i < drawBox.h; i++)
        {
            for (int j = 0; j < drawBox.w; j++)
            {
                const unsigned char b = assPtr[j];
                if (b > 0)
                {
                    uint32_t alpha = (uint32_t)(baseAlpha*b);
                    imgPtr[j] = color | (alpha<<24);
                }
            }
            imgPtr += vmat.w;
            assPtr += assImage->stride;
        }
        assImage = assImage->next;
    }

    m_prevRenderedImage = SubtitleImage(vmat, dispBox);
    return m_prevRenderedImage;
}

void SubtitleTrack_AssImpl::ClearRenderCache()
{
    for (auto clip : m_clips)
        clip->InvalidateImage();
}

void SubtitleTrack_AssImpl::ToggleOverrideStyle()
{
    int bit = ASS_OVERRIDE_DEFAULT;
    m_useOverrideStyle = !m_useOverrideStyle;
    if (m_useOverrideStyle)
        bit = ASS_OVERRIDE_FULL_STYLE;
    ass_set_selective_style_override_enabled(m_assrnd, bit);
}

void SubtitleTrack_AssImpl::UpdateTrackStyleByKeyPoints(int64_t pos)
{
    auto keyPoints = m_overrideStyle.GetKeyPoints();
    for (int i = 0; i < keyPoints->GetCurveCount(); i++)
    {
        auto name = keyPoints->GetCurveName(i);
        auto value = keyPoints->GetValueByDim(i, pos, ImGui::ImCurveEdit::DIM_X);
        if (name == "Scale")
        {
            _SetScaleX(value, false);
            _SetScaleY(value, false);
        }
        else if (name == "ScaleX")
            _SetScaleX(value, false);
        else if (name == "ScaleY")
            _SetScaleY(value, false);
        else if (name == "Spacing")
            _SetSpacing(value, false);
        else if (name == "Angle")
            _SetAngle(value, false);
        else if (name == "OutlineWidth")
            _SetOutlineWidth(value, false);
        else if (name == "ShadowDepth")
            _SetShadowDepth(value, false);
        else if (name == "OffsetH")
            _SetOffsetH(value, false);
        else if (name == "OffsetV")
            _SetOffsetV(value, false);
        else
            Log(WARN) << "[SubtitleTrack_AssImpl] UNKNOWN curve name '" << name << "', value=" << value << "." << endl;
    }
}

SubtitleTrackHolder SubtitleTrack_AssImpl::BuildFromFile(int64_t id, const string& url)
{
    ALogger* logger = GetSubtitleTrackLogger();
    SubtitleTrack_AssImpl* asssubtrk = new SubtitleTrack_AssImpl(id);
    SubtitleTrackHolder hSubTrk = SubtitleTrackHolder(asssubtrk);
    if (!asssubtrk->InitAss())
    {
        logger->Log(Error) << hSubTrk->GetError() << endl;
        return nullptr;
    }

    bool success = asssubtrk->ReadFile(url);
    asssubtrk->ReleaseFFContext();

    if (!success)
    {
        logger->Log(Error) << asssubtrk->GetError() << endl;
        return nullptr;
    }
    return hSubTrk;
}

SubtitleTrackHolder SubtitleTrack_AssImpl::NewEmptyTrack(int64_t id)
{
    ALogger* logger = GetSubtitleTrackLogger();
    SubtitleTrack_AssImpl* asssubtrk = new SubtitleTrack_AssImpl(id);
    SubtitleTrackHolder hSubTrk = SubtitleTrackHolder(asssubtrk);
    if (!asssubtrk->InitAss())
    {
        logger->Log(Error) << hSubTrk->GetError() << endl;
        return nullptr;
    }

    string assHeader = GenerateAssHeader("MediaEditor", 384, 288, "Arial", 16, 0xffffff, 0xffffff, 0, 0, 0, 0, 0, 1, 2);
    ass_process_codec_private(asssubtrk->m_asstrk, (char*)assHeader.c_str(), assHeader.size());

    asssubtrk->m_defaultStyleIdx = -1;
    for (int i = 0; i < asssubtrk->m_asstrk->n_styles; i++)
    {
        string styleName(asssubtrk->m_asstrk->styles[i].Name);
        if (styleName == "Default")
            asssubtrk->m_defaultStyleIdx = i;
    }
    if (asssubtrk->m_defaultStyleIdx < 0)
        asssubtrk->m_defaultStyleIdx = asssubtrk->m_asstrk->n_styles-1;

    if (asssubtrk->m_defaultStyleIdx >= 0)
    {
        asssubtrk->m_overrideStyle = SubtitleTrackStyle_AssImpl(asssubtrk->m_asstrk->styles+asssubtrk->m_defaultStyleIdx);
    }
    else
    {
        logger->Log(Error) << "No style is defined for this subtitle!" << endl;
        hSubTrk = nullptr;
    }
    return hSubTrk;
}

